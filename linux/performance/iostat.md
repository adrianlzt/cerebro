nfsiostat dentro del paquete nfs-utils

Parte del paquete systat: http://sebastien.godard.pagesperso-orange.fr/index.html
https://github.com/sysstat/sysstat


The iostat command is used for monitoring system input/output device loading by observing the time the devices are active in relation to their average transfer rates. The  iostat  command  generates  reports that can be used to change system configuration to better balance the input/output load between physical disks.

The first report generated by the iostat command provides statistics concerning the time since the system was booted, unless the -y option is  used  (in  this case, this first report is omitted). Each subsequent report covers the time since the previous report.

Los valores importantes:
  iowait
  avgqu-sz


Estadísticas extendidas del disco cada 5 segundos (si ponemos otro numero al final será el número de veces que se ejecutará el iostat)
iostat -dhNtxz 5

Si queremos ver particiones determinadas: iostat -dhNtxz 5 /dev/sda1 /dev/sda5

  -d Display the device utilization report.
  -h Make the Device Utilization Report easier to read by a human.
  -N Display the registered device mapper names for any device mapper devices.  Useful for viewing LVM2 statistics.
  -t Print the time for each report displayed
  -x Display extended statistics
  -z Tell iostat to omit output for any devices for which there was no activity during the sample period

  -c solo info de CPU
  -y excluye el primer report (media desde arranque)

tps: IOPS físicas, no lógicas (~100 random en SATA)
rrqm/s: The number of read requests merged per second that were queued to the device.
	Lo hacen algunos planificadores. Si tienen una cola de peticiones, intentan mergear peticiones cercanas. Es reordenar la cola de peticiones.
	En cargas de disco muy aleatorias no habrá merges. En discos fragmentados tampoco se podrán hacer merges.
	No me queda claro como se hacen merges. Si 
wrqm/s: The number of write requests merged per second that were queued to the device.
r/s: The number (after merges) of read requests completed per second for the device.
w/s: The number (after merges) of write requests completed per second for the device.
rsec/s: The number of sectors read from the device per second.
wsec/s: The number of sectors written to the device per second.
rkB/s: The number of sectors (kilobytes, megabytes) read from the device per second. (~100 en SATA)
wkB/s: The number of sectors (kilobytes, megabytes) written to the device per second. (~50 en SATA)
avgrq-sz: The average size (in sectors) of the requests that were issued to the device.
	  Valor falseado por readahead. A no ser que hagamos direct_io, el tamaño mínimo sería el de readahead.
avgqu-sz: The average queue length of the requests that were issued to the device.
	  El número de peticiones encoladas (el tamaño se ve en avgrq-sz)
	  IMPORTANTE! junto con iowait nos sirve para ver si nuestro sistema está saturado por io
	  si regularmente (los picos no importan) tienen valores más o menos altos (5 es valor alto)
	  se va a notar mucho la degradación
await: average time (milliseconds) for I/O requests issued to the device to be served. Includes the time spent by the requests in queue and the time spent servicing them.
r_await: average time (milliseconds) for read requests issued to the device to be served. Includes time spent by the requests in queue and the time spent servicing them.
w_await: average  time (ms) for write requests issued to the device to be served. This includes the time spent by the requests in queue and the time spent servicing them
svctm: WARNING! Do not trust this  field  any  more. This field will be removed in a future sysstat version.
%util: Percentage of CPU time during which I/O requests were issued to the device(BW utilization for the device).Device saturation occurs when this value is close to 100%

Info de CPU
  %user		% de uso de CPU en código de usuario sin niceness
  %nice		% de uso de CPU en código de usuario con niceness
  %system	% de uso de CPU de kernel 
  			aqui podemos ver si hay mucha carga de syscalls, ejemplo: dd if=/dev/zero of=/dev/null
  %iowait	% de tiempo esperando por operaciones IO
  			si iowait es alto es que la cpu está esperando al disco
			el significado es el porcentaje de tiempo que la cpu está esperando a disco
			valores por encima de 0,0 ya deberíamos tenerlo en cuenta
			el problema es tener un valor continuado por encima de 0, eso nos indica que el disco es el cuello de botella
			tener picos en iowait es normal, porque es cuando se producen escrituras a disco
  %steal	% de tiempo esperando por "robo" de ciclos de otra
  			el hipervisor va asignado ciclos a el host y a las vm. En el host veremos aquí los ciclos que se están asginando a las vm
  %idle		% de tiempo de CPU libre y no esperando IO
  			el tiempo total que la CPU está parada es %idle + %iowait




# Calculo await
https://github.com/sysstat/sysstat/blob/414e420b31983dfde62d844c4491dd881802a41e/common.c#L683

iostat toma medidas cada x segundos.
Para calcular el await, w_await y r_await lo que hace es:
tiempo dedicado a IO / numero de operaciones

Este tiempo se obtiene de /proc/diskstats, haciendo la diferencia entre el contador actual y la medida anterior.
El número de operaciones se obtiene de la misma manera.


Calculo r_arait, w_await:
https://github.com/sysstat/sysstat/blob/master/iostat.c#L942
